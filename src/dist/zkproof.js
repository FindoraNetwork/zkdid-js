"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySignedZKProof = exports.verifyZKProof = exports.generateZKProof = void 0;
const js_base64_1 = require("js-base64");
const credential_1 = require("./credential");
const circuit_1 = require("./circuit");
const tool_1 = require("./lib/tool");
const did_1 = require("./did");
/**
 * @remark This method generates a ZKProof instance based on a specific circuit
 *         The contents in `zkCred` is always trusted by API for now.
 * @param zkCred - An instance of ZKCredential
 * @param code - The circuit code to apply
 * @returns An instance of ZKProof
 * @throws Error if circuit doesn't exist
 */
const generateZKProof = async (zkCred, code) => {
    // Implementation
    // 1> The circuit being used MUST have already been created. Also make sure the code match the circuit's actual code.
    //
    // 2> User just decode `zkCred.credential` so he can see the values on credential.
    //    Real-world proof generation needs actual credential data (the values) as input. Since we're simulating proof generation,
    //    we just do the decoding job and stop for now.
    //
    // 3> Create an instance of `ZKProof` and fill in each field.
    //    Simply set field `zkproof` as `zkCred.credential` and pretend that it's well encrypted (so verifier won't see/decode).
    //
    // 4> Real-world proof generation is a time-consuming algorithm. For simulation, we can just randomly sleep 2~5 seconds in this API.
    await (0, tool_1.callApi)();
    const circuit = (0, circuit_1.getCircuit)(zkCred.purpose, code);
    if (code !== circuit.toCode()) {
        throw new Error(`Expected circuit code: '${code}', got '${circuit.toCode()}'.`);
    }
    return {
        code,
        proof: zkCred.credential,
        commitment: zkCred.commitment,
    };
};
exports.generateZKProof = generateZKProof;
/**
 * @remark This method verifies a ZKProof instance
 * @param zkProof - The instance of ZKProof
 * @param prover - Prover's address
 * @param purpose - The purpose of proof
 * @returns Result of proof verification
 * @throws Error if verification fails
 */
const verifyZKProof = (zkProof, prover, purpose) => {
    // Implementation
    //======================basic check
    //
    // 1> Fetch DID by `address` and fetch ZKCredential by `did` and `purpose`
    const did = (0, did_1.getDID)(prover);
    const zkCred = (0, credential_1.getZKCredential)(did, purpose);
    //
    // 2> Verify `zkCred` itself (nothing to do for now since `zkCred` is always trusted by API)
    //
    // 3> Make sure that `zkCred.did` === `did`, because prover can cheat by using a ZKProof generated by someone else.
    //
    // 4> Make sure that `zkCred.purpose` === `purpose` to prevent ZKCredential misuse
    //
    //
    //======================ZKP-related check (This is just a simulation!!)
    //
    // 5> The `zkProof.commitment` has to match `zkCred.commitment`
    //
    // 6> Fetch `circuit` by getCircuit(purpose, zkProof.code), the `circuit` MUST exist.
    //
    // 7> Decode `zkProof.proof` with Base64 and parse as object. (To simulate, verifier pretends that he/she can't see/decode actual values in the `zkProof.proof`)
    //    Example:
    if (!(0, did_1.didEqual)(zkCred.did, did))
        return false;
    if (zkCred.purpose !== purpose)
        return false;
    // ...
    if (zkCred.commitment !== zkProof.commitment)
        return false;
    const circuit = (0, circuit_1.getCircuit)(purpose, zkProof.code);
    const credObj = JSON.parse(js_base64_1.Base64.decode(zkProof.proof));
    const fields = new Map();
    Object.entries(credObj).forEach(([field, value]) => {
        fields.set(field, value);
    });
    return circuit.verify(fields);
    //
    // 8> Verify `fields` against `circuit` by `circuit.verify(fields)`
    //
};
exports.verifyZKProof = verifyZKProof;
/**
 * @remark This method verifies a SignedZKProof instance
 * @param signed - The instance of SignedZKProof
 * @param purpose - The purpose of proof
 * @returns Result of proof verification
 * @throws Error if verification fails
 */
const verifySignedZKProof = (signed, purpose) => {
    // Implementation
    //
    // 1> Recover signer(prover) `address` by ecrecover method (e.g., ethers.utils.recoverAddress)
    const address = 'recovered_address';
    return (0, exports.verifyZKProof)(signed.body, address, purpose);
};
exports.verifySignedZKProof = verifySignedZKProof;
