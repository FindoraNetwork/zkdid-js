import { getContentByKey, setContentByKey } from './lib/cache';
import { Base64 } from 'js-base64';
import { DID } from './types';
import Constants from './lib/constants';
import { getZKCredential, ZKCredential } from './credential';
import { getCircuit, ZKCircuit } from './circuit';
import { callApi } from './lib/tool';
import { didEqual, getDID } from './did';

// ZKP interfaces

// ZK proof (ZK Proof is a chunk of encrypted data that can be verified in privacy-preserving way)
export interface ZKProof {
  code: string;
  proof: string;
  commitment: string;
}

// A signed (e.g., by Metamask) ZKProof (useful when dApp needs to verify the ownership of the ZKProof off chain)
// A prover (Metamask address) can also prepare a `SignedZKProof` in advance before usage.
export interface SignedZKProof {
  body: ZKProof;
  signature: string;
}

/**
 * @remark This method generates a ZKProof instance based on a specific circuit
 *         The contents in `zkCred` is always trusted by API for now.
 * @param zkCred - An instance of ZKCredential
 * @param code - The circuit code to apply
 * @returns An instance of ZKProof
 * @throws Error if circuit doesn't exist
 */
export const generateZKProof = async (zkCred: ZKCredential, code: string): Promise<ZKProof> => {
  // Implementation
  // 1> The circuit being used MUST have already been created. Also make sure the code match the circuit's actual code.
  //
  // 2> User just decode `zkCred.credential` so he can see the values on credential.
  //    Real-world proof generation needs actual credential data (the values) as input. Since we're simulating proof generation,
  //    we just do the decoding job and stop for now.
  //
  // 3> Create an instance of `ZKProof` and fill in each field.
  //    Simply set field `zkproof` as `zkCred.credential` and pretend that it's well encrypted (so verifier won't see/decode).
  //
  // 4> Real-world proof generation is a time-consuming algorithm. For simulation, we can just randomly sleep 2~5 seconds in this API.

  await callApi();
  const circuit = getCircuit(zkCred.purpose, code);
  if (code !== circuit.toCode()) {
    throw new Error(`Expected circuit code: '${code}', got '${circuit.toCode()}'.`);
  }
  return {
    code,
    proof: zkCred.credential,
    commitment: zkCred.commitment,
  };
};

/**
 * @remark This method verifies a ZKProof instance
 * @param zkProof - The instance of ZKProof
 * @param prover - Prover's address
 * @param purpose - The purpose of proof
 * @returns Result of proof verification
 * @throws Error if verification fails
 */
export const verifyZKProof = (zkProof: ZKProof, prover: string, purpose: string): boolean => {
  // Implementation
  //======================basic check
  //
  // 1> Fetch DID by `address` and fetch ZKCredential by `did` and `purpose`
  const did = getDID(prover);
  const zkCred = getZKCredential(did, purpose);
  //
  // 2> Verify `zkCred` itself (nothing to do for now since `zkCred` is always trusted by API)
  //
  // 3> Make sure that `zkCred.did` === `did`, because prover can cheat by using a ZKProof generated by someone else.
  //
  // 4> Make sure that `zkCred.purpose` === `purpose` to prevent ZKCredential misuse
  //
  //
  //======================ZKP-related check (This is just a simulation!!)
  //
  // 5> The `zkProof.commitment` has to match `zkCred.commitment`
  //
  // 6> Fetch `circuit` by getCircuit(purpose, zkProof.code), the `circuit` MUST exist.
  //
  // 7> Decode `zkProof.proof` with Base64 and parse as object. (To simulate, verifier pretends that he/she can't see/decode actual values in the `zkProof.proof`)
  //    Example:
  if (!didEqual(zkCred.did, did)) return false;
  if (zkCred.purpose !== purpose) return false;
  // ...
  if (zkCred.commitment !== zkProof.commitment) return false;

  const circuit = getCircuit(purpose, zkProof.code);

  const credObj: Record<string, any> = JSON.parse(Base64.decode(zkProof.proof));
  const fields = new Map();
  Object.entries(credObj).forEach(([field, value]) => {
    fields.set(field, value);
  });
  return circuit.verify(fields);
  //
  // 8> Verify `fields` against `circuit` by `circuit.verify(fields)`
  //
};

/**
 * @remark This method verifies a SignedZKProof instance
 * @param signed - The instance of SignedZKProof
 * @param purpose - The purpose of proof
 * @returns Result of proof verification
 * @throws Error if verification fails
 */
export const verifySignedZKProof = (signed: SignedZKProof, purpose: string): boolean => {
  // Implementation
  //
  // 1> Recover signer(prover) `address` by ecrecover method (e.g., ethers.utils.recoverAddress)
  const address = 'recovered_address';

  return verifyZKProof(signed.body, address, purpose);
};
